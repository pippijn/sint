# generated by datamodel-codegen:
#   filename:  schema.json
#   timestamp: 2025-12-14T12:14:19+00:00

from __future__ import annotations

from enum import Enum
from typing import Annotated, Any, Literal, Optional, Union
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field, RootModel


class AttackEffect1(Enum):
    Fireball = 'Fireball'
    Leak = 'Leak'
    Boarding = 'Boarding'
    Hidden = 'Hidden'
    Miss = 'Miss'


class AttackEffect2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Special: str


class AttackEffect(RootModel[Union[AttackEffect1, AttackEffect2]]):
    root: Union[AttackEffect1, AttackEffect2]


class CardId(Enum):
    AfternoonNap = 'AfternoonNap'
    Amerigo = 'Amerigo'
    AnchorLoose = 'AnchorLoose'
    AnchorStuck = 'AnchorStuck'
    AttackWave = 'AttackWave'
    BigLeak = 'BigLeak'
    Blockade = 'Blockade'
    CloggedPipe = 'CloggedPipe'
    CostumeParty = 'CostumeParty'
    FallingGift = 'FallingGift'
    FalseNote = 'FalseNote'
    FluWave = 'FluWave'
    FogBank = 'FogBank'
    GoldenNut = 'GoldenNut'
    HighPressure = 'HighPressure'
    HighWaves = 'HighWaves'
    JammedCannon = 'JammedCannon'
    Leak = 'Leak'
    LightsOut = 'LightsOut'
    Listing = 'Listing'
    LuckyDip = 'LuckyDip'
    ManOverboard = 'ManOverboard'
    MicePlague = 'MicePlague'
    MonsterDough = 'MonsterDough'
    NoLight = 'NoLight'
    Overheating = 'Overheating'
    Panic = 'Panic'
    PeppernutRain = 'PeppernutRain'
    Present = 'Present'
    Recipe = 'Recipe'
    Rudderless = 'Rudderless'
    SeagullAttack = 'SeagullAttack'
    Seasick = 'Seasick'
    ShoeSetting = 'ShoeSetting'
    ShortCircuit = 'ShortCircuit'
    SilentForce = 'SilentForce'
    SingASong = 'SingASong'
    SlipperyDeck = 'SlipperyDeck'
    StaticNoise = 'StaticNoise'
    StickyFloor = 'StickyFloor'
    Stowaway = 'Stowaway'
    StrongHeadwind = 'StrongHeadwind'
    SugarRush = 'SugarRush'
    TheBook = 'TheBook'
    TheStaff = 'TheStaff'
    TurboMode = 'TurboMode'
    WailingAlarm = 'WailingAlarm'
    WeirdGifts = 'WeirdGifts'
    WheelClamp = 'WheelClamp'


class CardType1(Enum):
    Flash = 'Flash'
    Situation = 'Situation'


class Timebomb(BaseModel):
    rounds_left: Annotated[int, Field(ge=0)]


class CardType2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Timebomb_1: Annotated[Timebomb, Field(alias='Timebomb')]


class CardType(RootModel[Union[CardType1, CardType2]]):
    root: Union[CardType1, CardType2]


class ChatMessage(BaseModel):
    sender: str
    text: str
    timestamp: Annotated[int, Field(ge=0)]


class EffectType1(Enum):
    None_ = 'None'


class EffectType2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    DamageHull: int


class EffectType3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    LoseResource: Annotated[list[Any], Field(max_length=2, min_length=2)]


class EffectType4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    MovePlayer: Annotated[list[Any], Field(max_length=2, min_length=2)]


class EffectType5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    SpawnHazard: Annotated[list[Any], Field(max_length=2, min_length=2)]


class EffectType(
    RootModel[Union[EffectType1, EffectType2, EffectType3, EffectType4, EffectType5]]
):
    root: Union[EffectType1, EffectType2, EffectType3, EffectType4, EffectType5]


class EnemyState(Enum):
    Active = 'Active'
    Defeated = 'Defeated'


class Payload(BaseModel):
    to_room: Annotated[int, Field(ge=0)]


class GameAction1(BaseModel):
    payload: Payload
    type: Literal['Move']


class GameAction2(BaseModel):
    type: Literal['Bake']


class GameAction3(BaseModel):
    type: Literal['Shoot']


class GameAction4(BaseModel):
    type: Literal['RaiseShields']


class GameAction5(BaseModel):
    type: Literal['EvasiveManeuvers']


class GameAction6(BaseModel):
    type: Literal['Interact']


class GameAction7(BaseModel):
    type: Literal['Extinguish']


class GameAction8(BaseModel):
    type: Literal['Repair']


class Payload1(BaseModel):
    item_index: Annotated[int, Field(ge=0)]
    target_player: str


class GameAction9(BaseModel):
    payload: Payload1
    type: Literal['Throw']


class Payload3(BaseModel):
    item_index: Annotated[int, Field(ge=0)]


class GameAction11(BaseModel):
    payload: Payload3
    type: Literal['Drop']


class Payload4(BaseModel):
    target_player: str


class GameAction12(BaseModel):
    payload: Payload4
    type: Literal['Revive']


class GameAction13(BaseModel):
    type: Literal['Lookout']


class GameAction14(BaseModel):
    payload: Payload4
    type: Literal['FirstAid']


class Payload6(BaseModel):
    message: str


class GameAction15(BaseModel):
    payload: Payload6
    type: Literal['Chat']


class Payload7(BaseModel):
    ready: bool


class GameAction16(BaseModel):
    payload: Payload7
    type: Literal['VoteReady']


class GameAction17(BaseModel):
    type: Literal['Pass']


class Payload8(BaseModel):
    action_id: UUID


class GameAction18(BaseModel):
    payload: Payload8
    type: Literal['Undo']


class GamePhase(Enum):
    Lobby = 'Lobby'
    Setup = 'Setup'
    MorningReport = 'MorningReport'
    EnemyTelegraph = 'EnemyTelegraph'
    TacticalPlanning = 'TacticalPlanning'
    Execution = 'Execution'
    EnemyAction = 'EnemyAction'
    GameOver = 'GameOver'
    Victory = 'Victory'


class HazardType(Enum):
    Fire = 'Fire'
    Water = 'Water'


class ItemType(Enum):
    Peppernut = 'Peppernut'
    Extinguisher = 'Extinguisher'
    Keychain = 'Keychain'
    Wheelbarrow = 'Wheelbarrow'
    Mitre = 'Mitre'


class MapLayout(Enum):
    Star = 'Star'
    Torus = 'Torus'


class Payload9(BaseModel):
    name: str


class MetaAction1(BaseModel):
    payload: Payload9
    type: Literal['Join']


class MetaAction2(BaseModel):
    payload: Payload9
    type: Literal['SetName']


class Payload11(BaseModel):
    layout: MapLayout


class MetaAction3(BaseModel):
    payload: Payload11
    type: Literal['SetMapLayout']


class Payload12(BaseModel):
    state_json: str


class MetaAction4(BaseModel):
    payload: Payload12
    type: Literal['FullSync']


class MetaAction(RootModel[Union[MetaAction1, MetaAction2, MetaAction3, MetaAction4]]):
    root: Union[MetaAction1, MetaAction2, MetaAction3, MetaAction4]


class PlayerStatus(Enum):
    Fainted = 'Fainted'
    Silenced = 'Silenced'


class Neighbor(RootModel[int]):
    root: Annotated[int, Field(ge=0)]


class RoomName(Enum):
    CentralHallway = 'CentralHallway'
    Bow = 'Bow'
    Dormitory = 'Dormitory'
    Cargo = 'Cargo'
    Engine = 'Engine'
    Kitchen = 'Kitchen'
    Cannons = 'Cannons'
    Bridge = 'Bridge'
    Sickbay = 'Sickbay'
    Storage = 'Storage'
    CorridorA = 'CorridorA'
    CorridorB = 'CorridorB'
    CorridorC = 'CorridorC'


class SystemType(Enum):
    Bow = 'Bow'
    Dormitory = 'Dormitory'
    Cargo = 'Cargo'
    Engine = 'Engine'
    Kitchen = 'Kitchen'
    Cannons = 'Cannons'
    Bridge = 'Bridge'
    Sickbay = 'Sickbay'
    Storage = 'Storage'


class CardOption(BaseModel):
    effect: EffectType
    text: str


class CardSolution(BaseModel):
    ap_cost: Annotated[int, Field(ge=0)]
    item_cost: Optional[ItemType] = None
    required_players: Annotated[int, Field(ge=0)]
    target_system: Optional[SystemType] = None


class EnemyAttack(BaseModel):
    effect: AttackEffect
    target_room: Annotated[int, Field(ge=0)]
    target_system: Optional[SystemType] = None


class Payload2(BaseModel):
    item_type: ItemType


class GameAction10(BaseModel):
    payload: Payload2
    type: Literal['PickUp']


class GameAction(
    RootModel[
        Union[
            GameAction1,
            GameAction2,
            GameAction3,
            GameAction4,
            GameAction5,
            GameAction6,
            GameAction7,
            GameAction8,
            GameAction9,
            GameAction10,
            GameAction11,
            GameAction12,
            GameAction13,
            GameAction14,
            GameAction15,
            GameAction16,
            GameAction17,
            GameAction18,
        ]
    ]
):
    root: Union[
        GameAction1,
        GameAction2,
        GameAction3,
        GameAction4,
        GameAction5,
        GameAction6,
        GameAction7,
        GameAction8,
        GameAction9,
        GameAction10,
        GameAction11,
        GameAction12,
        GameAction13,
        GameAction14,
        GameAction15,
        GameAction16,
        GameAction17,
        GameAction18,
    ]


class Player(BaseModel):
    ap: int
    hp: int
    id: str
    inventory: list[ItemType]
    is_ready: Annotated[
        bool,
        Field(
            description='Has this player voted "Ready" for the current proposal batch?'
        ),
    ]
    name: str
    room_id: Annotated[int, Field(ge=0)]
    status: list[PlayerStatus]


class ProposedAction(BaseModel):
    action: GameAction
    id: UUID
    player_id: str


class Room(BaseModel):
    hazards: list[HazardType]
    id: Annotated[int, Field(ge=0)]
    items: list[ItemType]
    name: RoomName
    neighbors: list[Neighbor]
    system: Optional[SystemType] = None


class SmallMapUint32Room(RootModel[dict[str, Room]]):
    root: dict[str, Room]


class Action(RootModel[Union[GameAction, MetaAction]]):
    root: Union[GameAction, MetaAction]


class Card(BaseModel):
    affected_player: Annotated[
        Optional[str],
        Field(
            description='The player targeted or affected by this card (e.g. The Reader)'
        ),
    ] = None
    card_type: CardType
    description: str
    id: CardId
    options: Annotated[
        list[CardOption], Field(description='If the card offers a choice (Dilemma)')
    ]
    solution: Annotated[
        Optional[CardSolution], Field(description='Solution for Situations/Timebombs')
    ] = None
    title: str


class Enemy(BaseModel):
    hp: int
    max_hp: int
    name: str
    next_attack: Annotated[
        Optional[EnemyAttack],
        Field(description='What the enemy plans to do next (Telegraphing)'),
    ] = None
    state: EnemyState


class FieldMapPlayer(RootModel[dict[str, Player]]):
    root: dict[str, Player]


class GameMap(BaseModel):
    rooms: SmallMapUint32Room


class GameState(BaseModel):
    active_situations: Annotated[
        list[Card], Field(description='Active "Situation" cards')
    ]
    boss_level: Annotated[int, Field(description='Current Boss Level (0-3)', ge=0)]
    chat_log: Annotated[
        list[ChatMessage],
        Field(description='Chat History (Event Sourcing derived or stored)'),
    ]
    deck: Annotated[list[CardId], Field(description='The Draw Deck')]
    discard: Annotated[list[CardId], Field(description='The Discard Pile')]
    enemy: Annotated[Enemy, Field(description='The Enemy (Boss)')]
    evasion_active: bool
    hull_integrity: Annotated[int, Field(description='Ship Health (starts at 20)')]
    is_resting: bool
    latest_event: Annotated[
        Optional[Card],
        Field(
            description='The card drawn this turn (Flash or Situation) for display in MorningReport'
        ),
    ] = None
    layout: Annotated[
        MapLayout, Field(description='The Map Layout (Star, Torus, etc.)')
    ]
    map: Annotated[GameMap, Field(description='The Map')]
    phase: Annotated[GamePhase, Field(description='Current game phase')]
    players: Annotated[FieldMapPlayer, Field(description='The Players')]
    proposal_queue: Annotated[
        list[ProposedAction],
        Field(description='Proposed Actions (for Tactical Planning phase)'),
    ]
    rng_seed: Annotated[
        int, Field(description='Random seed for the next deterministic event', ge=0)
    ]
    sequence_id: Annotated[
        int, Field(description='Incremental version for P2P sync', ge=0)
    ]
    shields_active: bool
    turn_count: Annotated[
        int,
        Field(
            description='Total Action Points available to the team (shared pool logic or just tracking)\nIn v2 rules: Each player has 2 AP. This might track "rounds" or be unused.\nWe\'ll track the round number.',
            ge=0,
        ),
    ]


class FullSchema(BaseModel):
    action: Action
    state: GameState
